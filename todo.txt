Provide a documentation about the program.

1. Identify Your Audiences:

End-Users: People who will download and use the application. They need to know how to install it, what the features are, and how to use them effectively (search syntax, options, interpreting results).
Developers: Anyone contributing to the codebase (or you, six months from now!). They need to understand the project structure, setup, architecture, coding conventions, and how to contribute.
2. Choose Documentation Types and Locations:

You'll likely use a combination of these:

README.md (Project Root):
Audience: Everyone (first point of contact).
Content: High-level overview, core features, quick start (installation/running), links to more detailed docs, build status, license info.
Code Comments (JSDoc/TSDoc):
Audience: Developers.
Content: Explain why code is written a certain way, clarify complex logic, document function parameters, return types, class purposes, and public APIs (especially for reusable components or services like fileSearchService). Use TSDoc syntax for TypeScript benefits.
Markdown Files in /docs Directory:
Audience: Users and/or Developers (can be separate files).
Content: More detailed guides.
User Guide: Installation steps (per OS if needed), detailed feature walkthroughs (Search Form options, Query Builder syntax/examples, Results View modes, Settings, History), troubleshooting/FAQ. Use screenshots!
Developer Guide: Project setup (git clone, npm install, npm run dev), architecture overview (Electron Main/Renderer, IPC communication, key libraries like i18next, react-window, picomatch, shadcn/ui), folder structure explanation, build/distribution process (npm run dist), contribution guidelines (CONTRIBUTING.md), security practices followed.
API Reference (Optional): If you have complex internal APIs or plan for extensibility, you might auto-generate this from TSDoc comments (see tools below).
CONTRIBUTING.md (Project Root):
Audience: Developers wanting to contribute.
Content: How to set up the dev environment, coding style guidelines, how to submit pull requests, issue reporting process.
LICENSE (Project Root):
Audience: Everyone.
Content: The actual text of your chosen open-source license (e.g., MIT, Apache 2.0).
3. Implementation Steps & Tools:

Here’s a practical approach:

Step 1: Foundational Markdown Files

(Enhance) README.md: Make sure it clearly states the app's purpose, lists key features (including recent additions like query builder, history, themes), provides basic installation/usage steps, and links to the /docs directory if you create one.
Create LICENSE: Choose a license (e.g., MIT is common and permissive) and add the license text to this file. GitHub can help generate this.
Create CONTRIBUTING.md: Outline basic contribution steps.
Create a /docs directory: Inside your project root (D:/Code/Electron/docs).
Step 2: Write Code Comments (TSDoc)

Go through your key files (main.ts, fileSearchService.ts, complex React components like SearchForm.tsx, ResultsDisplay.tsx, QueryBuilder.tsx, utility functions).
Add TSDoc comments (/** ... */) above functions, classes, interfaces, and complex logic blocks.
Example (fileSearchService.ts):
typescript
/**
 * Searches files based on specified criteria, including path, extension, content, and metadata.
 * Provides progress updates and handles cancellation requests.
 *
 * @param params - The search parameters defining the scope and filters.
 * @param progressCallback - Function to call with progress updates.
 * @param checkCancellation - Function that returns true if the search should be cancelled.
 * @returns A promise resolving to the search results, including output, structured items, and error details.
 * @throws {Error} If critical setup like p-limit fails.
 */
export async function searchFiles(
  params: SearchParams,
  progressCallback: ProgressCallback,
  checkCancellation: CancellationChecker,
): Promise<SearchResult> {
  // ... implementation ...
}

/**
 * Parses a "YYYY-MM-DD" string into a Date object representing the START of that day.
 * @param dateString - The date string to parse.
 * @returns A Date object or null if the input is invalid.
 */
function parseDateStartOfDay(dateString: string | undefined): Date | null {
    // ... implementation ...
}
Use ESLint: Configure ESLint with a TSDoc plugin (eslint-plugin-jsdoc with TypeScript support or eslint-plugin-tsdoc) to enforce comment style and presence.
Step 3: Create User Guide (/docs/user-guide.md)

Start writing explanations for end-users.
Installation: How to get the dmg, AppImage, portable.exe, or msi and install/run it.
Interface Overview: Briefly explain the main sections (Search Form, Results, Settings, History).
Search Form: Detail each field:
Paths, Extensions (comma/newline separation).
Exclusion patterns (explain glob/regex briefly, give examples). Folder exclusion modes.
Max Depth.
Date pickers (how to use calendar, keyboard input format DD.MM.YYYY).
Size filters.
Query Builder: This needs good examples!
Explain AND/OR logic.
Term: Simple text, quotes for phrases, case sensitivity checkbox.
Regex: /pattern/flags syntax, examples.
NEAR: NEAR(term1, term2, distance) syntax, explain word distance, examples with text and regex.
Results View: Text vs. Tree mode, filtering results, copy/save buttons, clipboard warning, syntax highlighting (mention supported languages implicitly).
Settings: Language, Theme.
History: Viewing, loading, filtering, naming, favoriting, deleting.
Troubleshooting: Common errors (path not found, permissions), what to do.
Step 4: Create Developer Guide (/docs/developer-guide.md)

Getting Started: git clone, npm install, npm run dev. Explain the dev server and Electron window.
Project Structure: Briefly describe the purpose of src/electron, src/ui, src/components/ui, src/lib, public/locales, vite.config.ts, tsconfig.*.json, electron-builder.json.
Architecture:
Electron Main (main.ts) vs. Renderer (App.tsx).
Preload Script (preload.cts) and Context Isolation.
IPC Communication (ipcMain, ipcRenderer, contextBridge). List key channels (search-files, cancel-search, etc.).
Key Libraries: Briefly mention the role of i18next, react-window, picomatch, fast-glob, jsep, p-limit, shadcn/ui, date-fns, highlight.js.
State Management (UI): Primarily React component state (useState, useCallback, etc.).
Search Logic: High-level flow in fileSearchService.ts (glob -> filters -> processing -> cancellation checks).
i18n: How locales are structured (public/locales), how i18next is initialized and used (useTranslation).
Building: npm run build, npm run dist:*, npm run dist. Explain outputs.
Security: Mention CSP, contextIsolation: true, sandbox: true, validation of IPC senders.
Step 5: Consider Documentation Generators (Optional but Recommended)

Manually linking Markdown files works, but tools make it much better:

TypeDoc (for API Reference):

Generates HTML documentation directly from your TSDoc comments. Great for documenting exported functions, classes, types from fileSearchService.ts or shared utilities.
Install: npm install --save-dev typedoc
Configure: Create a typedoc.json file in your root.
json
// typedoc.json
{
  "entryPoints": ["./src/electron/fileSearchService.ts", "./src/ui/vite-env.d.ts", "./src/lib/utils.ts"], // Add key entry points
  "out": "docs-api", // Output directory
  "tsconfig": "tsconfig.json" // Point to your main tsconfig
}
Add Script: In package.json: "doc:api": "typedoc"
Run: npm run doc:api. Link to the generated docs-api/index.html from your README.md or Developer Guide.
Static Site Generators (for User/Developer Guides): These tools take your Markdown files (and potentially TypeDoc output) and build a searchable, navigable website.

Docusaurus: React-based, excellent integration, versioning, search (Algolia), theming, i18n support. Probably the best fit for a React project.
Setup: npx create-docusaurus@latest my-docs classic (run in project root, maybe name it website or docs-site).
Move your /docs/*.md files into the Docusaurus docs folder.
Configure docusaurus.config.js (sidebar, navbar).
Add scripts: "doc:dev": "cd my-docs && npm run start", "doc:build": "cd my-docs && npm run build".
VitePress: Simpler, Vite-native alternative. Also excellent for Vue/React projects using Vite. Less feature-rich than Docusaurus out-of-the-box but very fast.
Follow VitePress setup guide.
Structure Markdown files as needed.
Configure .vitepress/config.js.
Step 6: Maintain!

Documentation is only useful if it's accurate. Update it whenever you change features, fix bugs affecting usage, or refactor code significantly.
Treat documentation changes like code changes – include them in your pull requests.
Recommendation:

Start with README.md, LICENSE, CONTRIBUTING.md, and good TSDoc comments.
Create the User Guide and Developer Guide in Markdown (/docs). Use lots of screenshots for the User Guide.
Set up TypeDoc to generate API reference from your comments.
Consider setting up Docusaurus or VitePress later to tie it all together into a polished website, especially if the project grows or you want to publish it more formally.